- ![The Pragmatic Programmer Your Journey to Mastery, 20th Anniversary Edition by Andrew Hunt David Hurst Thomas.pdf](../assets/The_Pragmatic_Programmer_Your_Journey_to_Mastery,_20th_Anniversary_Edition_by_Andrew_Hunt_David_Hurst_Thomas_1735825070654_0.pdf)
  title:: Books/Pragmatic Programmer
- # Tips
- **Complete List of 100 Tips from The Pragmatic Programmer**
- ### **1. Care About Your Craft**
  
  Take pride in your work and strive to improve constantly. Quality matters.
- ### **2. Think! About Your Work**
  
  Don’t go on autopilot—critically analyze every decision you make.
- ### **3. Provide Options, Don’t Make Excuses**
  
  Instead of saying why something can’t be done, offer alternatives.
- ### **4. Don’t Live with Broken Windows**
  
  Fix small issues immediately before they become bigger problems.
- ### **5. Be a Catalyst for Change**
  
  Influence your team towards better practices and improvements.
- ### **6. Remember the Big Picture**
  
  Don’t get lost in details—understand how your work fits into the larger system.
- ### **7. Make Quality a Requirements Issue**
  
  Ensure quality is discussed upfront rather than as an afterthought.
- ### **8. Invest Regularly in Your Knowledge Portfolio**
  
  Stay relevant by continuously learning new technologies and practices.
- ### **9. Critically Analyze What You Read and Hear**
  
  Don’t blindly follow trends—evaluate new techniques and tools critically.
- ### **10. English is Just Another Programming Language**
  
  Communicate clearly and precisely—writing is as important as coding.
- ### **11. Know Your Tools**
  
  Master your development environment, editor, shell, and debugger.
- ### **12. Favor Clarity Over Cleverness**
  
  Write code that is easy to understand, even if it’s not the most "elegant."
- ### **13. Communicate!**
  
  Technical skill is useless if you can’t effectively convey your ideas.
- ### **14. DRY—Don’t Repeat Yourself**
  
  Each piece of knowledge should have a **single, authoritative** representation.
- ### **15. Eliminate Effects Between Unrelated Things**
  
  Ensure your code is **orthogonal**—components should be independent.
- ### **16. Use Tracer Bullets to Find the Target**
  
  Implement small, working end-to-end pieces to validate your approach.
- ### **17. Prototype to Learn**
  
  Use prototypes to explore ideas before committing to full implementation.
- ### **18. Program Close to the Problem Domain**
  
  Use languages and abstractions that reflect the problem space.
- ### **19. Estimate to Avoid Surprises**
  
  Provide realistic estimates and update them as you learn more.
- ### **20. Iterate the Schedule with the Code**
  
  Keep project schedules flexible and adjust them based on actual progress.
- ### **21. Keep Knowledge in Plain Text**
  
  Plain text is future-proof and easily accessible.
- ### **22. Use the Power of Command Shells**
  
  Master command-line tools to improve efficiency.
- ### **23. Use a Single Editor Well**
  
  Become fluent in your text editor to increase productivity.
- ### **24. Always Use Source Code Control**
  
  Version control is your safety net—use it for everything.
- ### **25. Fix the Problem, Not the Blame**
  
  Focus on solving issues rather than pointing fingers.
- ### **26. Don’t Panic**
  
  Stay calm and analyze problems logically.
- ### **27. Failing Test Before Fixing Code**
  
  Use tests to verify and understand failures before fixing them.
- ### **28. Read the Damn Error Message**
  
  Pay close attention to error messages—they often tell you exactly what’s wrong.
- ### **29. Reproduce Bugs Before Fixing Them**
  
  A bug that can’t be reproduced is a bug that isn’t truly fixed.
- ### **30. Eliminate the Impossible**
  
  Use logic to rule out incorrect assumptions when debugging.
- ### **31. Don’t Assume It—Prove It**
  
  Test your assumptions before relying on them.
- ### **32. Learn a Text Manipulation Language**
  
  Master tools like **sed**, **awk**, or **Python** for quick data processing.
- ### **33. Write Code That Writes Code**
  
  Use code generation and metaprogramming when appropriate.
- ### **34. You Can’t Write Perfect Software**
  
  Software will always have bugs—write defensively.
- ### **35. Design with Contracts**
  
  Clearly define preconditions, postconditions, and invariants.
- ### **36. Crash Early**
  
  Fail fast instead of letting a broken system continue running unpredictably.
- ### **37. Use Assertions to Prevent the Impossible**
  
  Assertions help catch unexpected errors early in development.
- ### **38. Use Exceptions for Exceptional Problems**
  
  Don’t use exceptions for normal control flow.
- ### **39. Finish What You Start**
  
  Incomplete features and code cause unnecessary complexity.
- ### **40. Minimize Coupling Between Components**
  
  Loose coupling makes systems more maintainable.
- ### **41. Configure, Don’t Integrate**
  
  Use **configuration** rather than hardcoded values for flexibility.
- ### **42. Don’t Rely on Magic**
  
  Understand how frameworks and libraries work under the hood.
- ### **43. Don’t Repeat Yourself in Documentation**
  
  Avoid redundant documentation—use **self-documenting code** where possible.
- ### **44. Design for the Future, but Not Too Much**
  
  Plan for change but don’t over-engineer upfront.
- ### **45. Make Interfaces Easy to Use Correctly and Hard to Use Incorrectly**
  
  Good API design prevents misuse.
- ### **46. Treat Documentation as a User Interface**
  
  Ensure documentation is clear, structured, and accessible.
- ### **47. Automate Your Tests**
  
  Use automated tests to prevent regressions.
- ### **48. Test Early, Test Often, Test Automatically**
  
  Continuous testing leads to more reliable software.
- ### **49. Find Bugs Once**
  
  Ensure the same bug doesn’t happen twice—write tests for fixes.
- ### **50. Refactor Early, Refactor Often**
  Continuously improve the structure of your code.
- ### **51. Test Your Code, or Your Users Will**
  
  If you don’t test your code, expect users to find the bugs for you.
- ### **52. Don’t Gather Requirements—Dig for Them**
  
  Users often don’t know what they need—ask the right questions.
- ### **53. Work with a User to Think Like a User**
  
  Collaborate with users to design effective solutions.
- ### **54. Abstractions Live Longer than Details**
  
  Focus on high-level concepts rather than implementation details.
- ### **55. Use a Project Glossary**
  
  Define terminology clearly to avoid confusion.
- ### **56. Don’t Think Outside the Box—Find the Box**
  
  Identify the real constraints before trying to innovate.
- ### **57. Start When You’re Ready**
  
  Don’t rush into coding—prepare properly first.
- ### **58. Some Things Are Better Done than Described**
  
  Show working code instead of explaining ideas abstractly.
- ### **59. Don’t Be Afraid to Break Things**
  
  Sometimes breaking things leads to better solutions.
- ### **60. Use the Right Algorithm and Data Structure**
  
  Performance often depends on choosing the right structure.
- ### **61. Value Your Time**
  
  Automate repetitive tasks and optimize your workflow.
- ### **62. Finish What You Start**
  
  Abandoned features and half-done refactoring create technical debt.
- ### **63. Prototype to Mitigate Risk**
  
  Quick prototypes help uncover issues before full development.
- ### **64. Keep It Simple and Minimal**
  
  Avoid unnecessary complexity—simpler solutions are often better.
- ### **65. Keep Technology Independent**
  
  Don’t tie your code to a specific technology or vendor.
- ### **66. Beware the Curse of the Premature Optimizer**
  
  Optimize only where necessary—don’t over-engineer early.
- ### **67. Code in a Consistent Style**
  
  Use consistent formatting and naming conventions.
- ### **68. Don’t Program by Coincidence**
  
  Understand why your code works—don’t rely on luck.
- ### **69. Test State Coverage, Not Just Code Paths**
  
  Test different data states, not just execution paths.
- ### **70. Write Code for Humans, Not Just Machines**
  
  Make your code readable and maintainable.
- ### **71. Avoid Global Data**
  
  Global variables create hidden dependencies and make debugging harder.
- ### **72. Take Small, Deliberate Steps**
  
  Incremental development is more manageable and less risky.
- ### **73. Code Should Be Easy to Delete, Not Easy to Extend**
  
  Favor simplicity and modularity over extensibility.
- ### **74. The Bigger the Interface, the Weaker the Abstraction**
  
  Small, well-defined interfaces are better than large, complex ones.
- ### **75. If It’s Hard to Test, It’s Badly Designed**
  
  Hard-to-test code is usually tightly coupled and poorly structured.
- ### **76. Use Metaprogramming Sparingly**
  
  Metaprogramming can be powerful, but it adds complexity.
- ### **77. Design Systems to Be Replaced**
  
  Good software should allow for parts to be swapped out when needed.
- ### **78. Keep Documentation Close to Code**
  
  Documentation should be easy to update alongside code changes.
- ### **79. Beware of Overengineering**
  
  Build only what you need—extra complexity leads to problems.
- ### **80. Design for Concurrency**
  
  Modern applications should handle parallel execution gracefully.
- ### **81. Separate Policy from Implementation**
  
  Business logic should be separate from low-level implementation details.
- ### **82. Time Changes Everything**
  
  Plan for change—your software will need to evolve.
- ### **83. Make Code Easy to Change**
  
  Code that’s easy to modify is better than code that’s "perfect" but rigid.
- ### **84. Encourage Collective Code Ownership**
  
  All team members should feel responsible for the entire codebase.
- ### **85. Always Use Version Control**
  
  Track changes to your code with a good VCS like Git.
- ### **86. The Best Code Is No Code at All**
  
  Avoid writing unnecessary code—simplify whenever possible.
- ### **87. Design Software, Not Just Programs**
  
  Think in terms of systems, not just isolated code snippets.
- ### **88. Understand the Cost of Change**
  
  Factor in technical debt and refactoring costs in your planning.
- ### **89. Use Checklists to Reduce Errors**
  
  Checklists help prevent mistakes in complex processes.
- ### **90. Trust, but Verify**
  
  Review dependencies and external libraries carefully.
- ### **91. Make the Invisible Visible**
  
  Logging and monitoring help reveal hidden issues.
- ### **92. Continuous Learning Is Key**
  
  Always be learning and adapting to new developments in technology.
- ### **93. Write Code You Would Want to Maintain**
  
  Future-proof your code with clarity and good structure.
- ### **94. Expect the Unexpected**
  
  Handle edge cases and failures gracefully.
- ### **95. Automate Where Possible**
  
  Save time and reduce human error by automating processes.
- ### **96. Reduce Dependencies When Possible**
  
  Fewer dependencies mean fewer points of failure.
- ### **97. Know When to Walk Away**
  
  Sometimes rewriting or abandoning a project is the best choice.
- ### **98. Listen to the Code**
  
  Refactor when the code tells you something is wrong.
- ### **99. Software Is a Team Sport**
  
  Collaboration leads to better solutions than working in isolation.
- ### **100. Have Fun!**
  
  Programming should be enjoyable—embrace the challenges and rewards.